/* Include Files */
#include "neupr.h"

/* Function Definitions */
/*
 * MYNEURALNETWORKFUNCTION neural network simulation function.
 */
void neutest(const float x1[6], float b_y1[4])
{
    float b_x1[6];
    int k;
    static const float fv0[6] = { 0.083327651F, 0.0239779335F, 0.789832294F,
                                  0.188078314F, 0.10139782F, 0.164548218F };

    static const float fv1[6] = { 1.19660282F, 2.99854016F, 0.325779885F,
                                  1.19555926F, 2.02889466F, 1.86558795F };

    float fv2[10];
    float f0;
    int i0;
    static const float fv3[60] = { 0.992044687F, 1.23733282F, -1.11203718F,
                                   0.128634453F, -1.43836689F, 0.53217721F, 0.0319813192F, 2.47439146F,
                                   -1.4378041F, 0.477858633F, 0.797538221F, -1.4228307F, -2.13460779F,
                                   -0.00538964476F, 1.43247688F, -2.23375106F, 0.369587511F, 0.0451372936F,
                                   0.198382974F, -0.732535362F, -0.022894593F, 0.907892704F, 1.06757808F,
                                   2.00368977F, 0.3420344F, -1.13406777F, 0.0647512227F, -1.77761936F,
                                   1.48406339F, -0.69414717F, 1.43002605F, 0.777777612F, -0.64007622F,
                                   1.1194886F, -2.25535154F, -1.54435658F, 1.63653922F, 0.327335089F,
                                   -0.508709311F, 0.854979813F, 0.530825853F, -1.20371318F, 0.571229398F,
                                   -1.50120556F, 1.02187717F, -0.180109009F, -1.24806082F, 0.4691948F,
                                   -1.21987391F, -1.14928484F, 0.0136882607F, 1.41053438F, 2.49466944F,
                                   -1.04245508F, -1.74322593F, 1.53276432F, -1.78233027F, -0.807582498F,
                                   -1.05343461F, 0.931305468F };

    static const float fv4[10] = { -2.1957233F, -1.63179076F, 1.3593843F,
                                   0.456700832F, 1.55155075F, 1.17658019F, 0.332441866F, 1.49424088F,
                                   -1.79973722F, 1.94205606F };

    float fv5[10];
    static const float fv6[40] = { -0.777258277F, -0.00488227885F, -0.523766458F,
                                   0.520664692F, -0.763770103F, -1.15082288F, 2.59775138F, 0.0256744102F,
                                   0.563403249F, -4.0274272F, -0.149012461F, 2.96639085F, -3.53079247F,
                                   1.53712475F, 1.05541563F, 1.96359622F, 1.22293639F, 1.00913703F, -4.6956892F,
                                   1.64242518F, 0.545097589F, -2.72552848F, 2.06078959F, 1.05072653F,
                                   -2.74543095F, 0.355070889F, 0.854202032F, 0.624472737F, 0.252459049F,
                                   2.0291934F, 0.29748413F, -3.00371385F, -2.17546582F, 0.559148371F,
                                   -1.46483886F, 2.54236507F, 0.317589194F, -0.595093429F, 0.835160077F,
                                   -0.217853367F };

    static const float fv7[4] = { 0.00864214264F, 0.121901281F, -0.16385597F,
                                  -1.28273416F };

    float u0;
    float u1;
    float nmax;
    float denom;

    for (k = 0; k < 6; k++) {
        b_x1[k] = (x1[k] - fv1[k]) * fv0[k] + -1.0F;
    }

    for (k = 0; k < 10; k++) {
        f0 = 0.0F;
        for (i0 = 0; i0 < 6; i0++) {
            f0 += fv3[k + 10 * i0] * b_x1[i0];
        }

        fv2[k] = fv4[k] + f0;
    }

    /*  Layer 2 */
    for (k = 0; k < 10; k++) {
        fv5[k] = 2.0F / (1.0F + exp(-2.0F * fv2[k])) - 1.0F;
    }

    for (k = 0; k < 4; k++) {
        f0 = 0.0F;
        for (i0 = 0; i0 < 10; i0++) {
            f0 += fv6[k + (i0 << 2)] * fv5[i0];
        }

        b_y1[k] = fv7[k] + f0;
    }

    /*  a2 = softmax_apply(n2); */
    u0 = b_y1[0];
    u1 = b_y1[1];
    if (u0 >= u1) {
        nmax = u0;
    } else {
        nmax = u1;
    }

    if (b_y1[2] > nmax) {
        nmax = b_y1[2];
    }

    if (b_y1[3] > nmax) {
        nmax = b_y1[3];
    }

    for (k = 0; k < 4; k++) {
        b_y1[k] = exp(b_y1[k] - nmax);
    }

    denom = b_y1[0];
    for (k = 0; k < 3; k++) {
        denom += b_y1[k + 1];
    }

    if (denom == 0.0F) {
        denom = 1.0F;
    }

    /*  Output 1 */
    for (k = 0; k < 4; k++) {
        b_y1[k] /= denom;
    }
}

/*  Output 1 */

